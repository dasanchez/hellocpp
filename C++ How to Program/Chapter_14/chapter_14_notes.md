## Chapter 14: Templates

### 14.1 Introduction

- **Function templates** and **class templates** enable you to specify, with a single code segment, an entire range of related (overloaded) functions - called **function-template specializations** - or an entire range of related classes - called **class-template specializations**. This technique is called **generic programming**.
- We might write a single function template for an array-sort function, then have C++ generate separate function=template specializations that will sort `int` arrays, `float` arrays, `string` arrays and so on.
- We might write a single class template for a stack class, then have C++ generate separate class-template specializations, such as a stack-of-`int` class, a stack-of-`float` class, a stack-of-`string` class and so on.
- Most C++ compilers require the complete definition of a template to appear in the client source-code file that uses the template. For this reason and for reusability, templates are often defined in headers, which are then `#include`d in the appropriate client source-code files. For class templates, this means that the member functions are also defined in the header.

### 14.2 Function Templates

- Overloaded functions normally perform _similar_ or _identical_ operations on _different_ types of data. If the operations are _identical_ for each type, they can be expressed more compactly and conveniently using function templates.
- Function templates, like, macros, enable software reuse. Unlike macros, function templates eliminate many types of errors through the scrutiny of full C++ type checking.
- All **function-template definitions** begin with keyword **`template`** followed by a list of **template parameters** to the function template enclosed in **angle brackets**; each template parameter that represents a type _must_ be preceded by either of the interchangeable keywords `class` or **`typename`**:
```
template< typename T >
template< class ElementType >
template< typename BorderType, typename FillType >
```

- Keywords `typename` and `class` used to specify function-template parameters actually mean "any fundamental type or user-defined type".
- Not placing keyword `class` or keyword `typename` before each type template parameter of a function template is a syntax error.
- If a template is invoked with a user-defined type, and if that template uses functions ot operators (e.g. ==, +, <=) with objects of that class type, then those functions and operators must be overloaded for the user-defined type. Forgetting to overload such operators causes compilation errors.
- Multiple function-template specializations and class-template specializations are instantiated in a program (at compile time), despite the fact that the templates are written only once. These copies con consume considerable memory. This is not normally an issue, because the code generated by the template is the same size as the code you'd have written to produce the separate overloaded functions.

### 14.3 Overloading Function Templates

- We can provide other function templates that specify the same function name but with different function parameters.
- We can also overload a function template by providing nontemplate functions with the same function name but different function arguments.
- A compilation error occurs if no matching function definition can be found for a particular function call or if there are multiple matches that the compiler considers ambiguous.

### 14.4 Class Templates

- It's possible to understand the concept of a "stack" independent of the type of the items being placed in it. However, to instantiate a stack, a data type must be specified. We need the means for describing the notion of a stack _generically_ and instantiating classes that are _type-specific_ versions of this generic stack class. C++ provides this capability through **class templates**.
- Class templates encourage software reusability by enabling type-specific versions of generic classes to be instantiated.
- Class templates are called **parameterized types**, because they require one or more type parameters to specify how to customize a "generic class" template to form a class-template specialization.
- A class-template definition is preceded by the header:
```
template< typename T >
```
- to specify a class-template definition with type parameter T which acts as sa placeholder for the type of the class to be created. You need not specifically use identifier T, any valid identifier can be used.
- The member-function definitions of a class template are function templates. The member-function definitions that appear outside the class template definition each befin with the header `template< typename T >`.

### 14.5 Nontype Parameters and Default Types for Class Templates

- It's possible to use **non-type template parameters**, which can have default arguments and are treated as `const`s. The template header could be modified to take an `int` elements parameter as follows:
```
template< typename T, int elements > // nontype parameter elements
```
- In addition, a type parameter can specify a **default type**. For example:
```
template< typename T = string> // defaults to type string
```
- Default type parameters must be the _rightmost_ (trailing) parameters in a template's type-parameter list.
- When appropriate, specify the size of a container class (such as an array or a stack class) at compile time (possibly through a nontype template parameter). This eliminates the execution-time overhead of using `new` to create the space dynamically.
- Specifying the size of a container at compile time avoids the potentially fatal execution-time error if `new` is unable to obtain the needed memory.
- In some cases, it may not be possible to use a particular type with a class template. If a particular user-defined type will not work with the template or requires customized processing, you can define an ****explicit specialization** of the class template for a particular type:
```
template<>
class Stack< Employee >
{
  // body of class definition
};
```
- The `Stack<Employee>` explicit specialization is a complete replacement for the `Stack` class template that is specific to type `Employee`- it does not use anything from the original class template and can even have different members.
